<!-- .slide: class="center" -->

## 1.1. 计算机如何表示数字？

*从手指到比特*

----

## 人类是怎么数数的？

在计算机出现之前，

人类就已经在数数了。

> 我们最初是怎么开始数数的？

----

## 用手指数数！

人类有 10 根手指：

![10 fingers](https://www.emoji.family/api/emojis/1f450/noto/png/256)
<!-- .element: style="text-align:center" -->

> 所以，以 10 为一组来计数，对我们来说很自然。

----

## 十进制

我们使用 *十进制* 符号（数字）：

> 0 1 2 3 4 5 6 7 8 9

用到 9 之后，符号用完了，于是：
* 回到 0 <!-- .element: class="fragment" data-fragment-index="1" -->
* 向前进一位 <!-- .element: class="fragment" data-fragment-index="2" -->

**这个规则不是数学本身，而是关于"表示方式"。** <!-- .element: class="fragment" data-fragment-index="3" -->

----

## "十进制"是什么意思？

十进制的含义：

* **10** 个符号
* 每个位置的权重是 **10** 的幂
数值来源于 **位置**。

> `345 = 300 + 40 + 5`
> `    = 3 × 10² + 4 × 10¹ + 5 × 10⁰`

----

<!-- .slide: class="center" -->
## 十进制是唯一的计数方式吗？

----

<!-- .slide: class="center" -->
> 十进制是人类的选择。

----

## 计算机的选择

如果 **十进制** 源于人类的手指，

那计算机有什么样的"手指"呢？

> 计算机也有自己的选择。
> 但它们的选择受限于 ── **硬件**。

----

## 硬件限制了选择

在最底层，计算机只能可靠地区分：
* 开 / 关
* 高电平 / 低电平
* 1 / 0

> 这使得 **二进制** 成为了自然的选择。

----

## 二进制

计算机使用二进制数字：

> 0 1

就像 **十进制** 一样：
* 只有 2 个符号
* 每个位置有一个权重（2 的幂）

数值同样来源于 **位置**：

`1010 = 1 × 2³ + 0 × 2² + 1 × 2¹ + 0 × 2⁰`

----

## 十六进制

就像 **十进制** 和 **二进制** 一样：
* 十六进制有 16 个符号：0 1 2 3 4 5 6 7 8 9 A B C D E F
* 每个位置有一个权重（16 的幂）

数值同样来源于 **位置**：

`12A = 1 × 16² + 2 × 16¹ + 10 × 16⁰`

所以，二进制和十六进制与十进制遵循相同的思想。

----

<!-- .slide: class="center" -->
### 这个共同的思想有一个名字 ── 位值记数法

----

## 不同的表示方式

我们用符号来书写数字：
* 42
* 101010
* 2A

它们看起来不同，但可以表示相同的值。

> 是什么让它们不同？

----

## 什么不是区别？

区别不在于：
* 数值本身
* 计数的概念

----

## 符号数量很重要

每种表示方式使用不同的符号集：
* 十进制使用 10 个符号

  → `0 1 2 3 4 5 6 7 8 9`

* 二进制使用 2 个符号

  → `0 1`

* 十六进制使用 16 个符号

  → `0 1 2 3 4 5 6 7 8 9 A B C D E F`

这被称为：

> 数制的 **基数（Radix）**

----

## 基数表示法

任何以 𝑏 为基数的数可以表示为：

$$
(d_n d_{n-1} \dots d_1 d_0)_b
$$

| 基数 | 数字符号                        | 表示法     |
|:----:|:-------------------------------:|:----------:|
| 2    | 0 1                             | (1010)₂    |
| 10   | 0 1 2 3 4 5 6 7 8 9             | (42)₁₀     |
| 16   | 0 1 2 3 4 5 6 7 8 9 A B C D E F | (2A)₁₆     |

----

<!-- .slide: class="center" -->
## 计算机如何存储数字？

----

## 二进制中的数字

我们知道数字是用二进制数字表示的。

在计算机内部，二进制数字被表示为 **比特（bit）**。

`Digits :   1    0    1    0`

`           ↓    ↓    ↓    ↓`

`Bits   :   1    0    1    0`

> 这些比特存放在哪里？

----

## 比特存放在内存中

比特以组为单位存储在 **内存** 中。一组 8 个比特称为一个 **字节（byte）**。

内存是一长串字节序列：

```
+--------+--------+--------+--------+--------+--------+--------+
| byte 0 | byte 1 | byte 2 | byte 3 | byte 4 |  ....  | byte N |
+--------+--------+--------+--------+--------+--------+--------+
↓↓↓↓↓↓↓↓
10100101
```
<!-- .element: style="text-align:center" -->

内存是有序的，比特一个接一个地存储。

在实际程序中，我们在内存中存储很多数字。

> 所以，我们需要一种方式来知道 **一个数字在哪里结束，下一个数字从哪里开始**。

----

## 一个自然的想法

数字可以：
* 很小：`123`
* 很大：`23456789`

为什么不：
* 小数字用少一些的比特
* 大数字用多一些的比特？

> 听起来很高效，对吧？

----

## 可变长度的问题

如果数字使用不同数量的比特，

我们怎么找到下一个数字？

> 要找到第 10 个数字，是不是必须从头数起？

----

<!-- .slide: class="center" -->
### 如果每个数字使用相同数量的比特呢？

----

## 固定大小的数字

使用固定大小的数字，每个数字的位置都是可预测的。
固定大小解决了：

> 下一个数字在哪里？

但我们仍然需要选择：

> 每个数字用多少比特？

----

## 位宽

一个数字使用的比特数称为 **位宽（bit-width）**。
常见的选择：

```text
  bit-width | bits                                                            
------------+-----------------------------------------------------------------
    8-bit   | ▢▢▢▢▢▢▢▢                                                        
   16-bit   | ▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢                                                
   32-bit   | ▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢                                
   64-bit   | ▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢
```

> 为什么不总是用 64 位？

----

## 位宽是一种权衡

更多的比特意味着：
* 更大的范围
* 更多的内存

更少的比特意味着：
* 更小的范围
* 更少的内存

----

## 思考一下

如果我们存储 1,000,000 个数字：
* 8-bit → 1MB
* 32-bit → 4MB
* 64-bit → 8MB

> 同样数量的数字，不同的内存开销。
> 这在实际程序中很重要。

----

## 负数

到目前为止，我们可以在比特中存储数字。

但是负数呢？

我们怎么存储：
* -1
* -10
* -100
* ……？

----

## 回到数制

在 **位值记数法** 中，数字代表 **位值**，它们告诉我们：

> 一个数有多大。

但数字不知道 **方向**（正还是负）。

它们只表示大小，没有符号。

----

## 符号从哪里来？

如果数字只表示大小……

那我们必须用一些比特来表示 **符号**。

> 一个自然的选择是 ── 用 1 个比特来表示 **符号**

----

## 有符号数的表示

```text
 bit-width | bits                                                             
-----------+------------------------------------------------------------------
    8-bit  | ◌▢▢▢▢▢▢▢                                                         
   16-bit  | ◌▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢                                                
   32-bit  | ◌▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢                                
   64-bit  | ◌▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢▢


  ◌ → 符号位                                                                  
  ▢ → 数值位                                                                  
```

----

## 符号的代价

使用符号意味着：
* 数值位更少
* 值的范围更小

那么……
* 年龄
* 学生人数
* ……

> 我们总是需要 **符号** 吗？

----

## 无符号数

如果我们不需要负数，

就可以把所有比特都用于表示数值。

> 这种解读方式叫做 ── **无符号（Unsigned）**

----

## 整数范围：有符号 vs 无符号
```text
 bit-width |    Unsigned Range    |     Signed Range
-----------+----------------------+----------------------
    8-bit  |     0 ~ 2^8  − 1     |   −2^7  ~ 2^7  − 1
   16-bit  |     0 ~ 2^16 − 1     |   −2^15 ~ 2^15 − 1
   32-bit  |     0 ~ 2^32 − 1     |   −2^31 ~ 2^31 − 1
   64-bit  |     0 ~ 2^64 − 1     |   −2^63 ~ 2^63 − 1
```
<!-- .element: style="text-align:center" -->

> 有符号数牺牲了 **一半的范围** 来换取 **符号**

----

## 非整数

那像这样的数字呢：
* 3.1415926
* 0.1
* -2.5

我们能不能这样存储？

$$
3.1415926 \times 10000000 = 31415926
$$

> `1/3` 怎么办？

----

## 新的困难

如果我们缩放数字：
* 保留多少位小数？
* 如果数字非常大怎么办？
* 如果数字非常小怎么办？

> 我们需要同时表示 **大小** 和 **精度**

----

## 我们想要什么？

我们想要一种方式来表示：
* 非常大的数
* 非常小的数
* 用有限的比特

----

## 科学计数法

在数学中，我们可以写：
* `314.15926 = 3.1415926 × 10^2`
* `0.0000121 = 1.21 × 10^−5`

这就是 **科学计数法**。

$$
m \times 10^{n}, \quad 1 \le m < 10
$$


----

## 浮点数表示

计算机做了类似的事情：

$$
Number = Mantissa \times Base^{exponent}
$$

----

## 表示方式：整数 vs 浮点数

* 整数 → 精确
* 浮点数 → 近似

> 浮点数用精确性换取了范围
