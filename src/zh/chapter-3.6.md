<!-- .slide: class="center" -->

## 3.6. 排序

*把东西排好顺序*

----

## 为什么要排序？

排好序的数据 **威力巨大** ：

* 二分搜索只能在有序数据上使用 <!-- .element: class="fragment" -->
* 排好序的列表更容易阅读和理解 <!-- .element: class="fragment" -->
* 字典、通讯录、排行榜 ── 都是排好序的！ <!-- .element: class="fragment" -->

> 排序是计算机科学中最重要的任务之一。

----

## 给手里的牌排序

假设你手里有 5 张牌：**5, 3, 8, 1, 2**

你会怎么排序？

一个简单的方法：**比较相邻的两个数** ，如果顺序不对就交换。重复这个过程，直到全部排好！

> 这叫做 **冒泡排序** ── 最大的数会慢慢”浮”到最后面。

----

## 为什么叫”冒泡”排序？

![冒泡排序](src/zh/images/bubble-sort.svg) <!-- .element: style=”width: 35%” -->

就像水中的大气泡会浮到水面一样，**大的数字会”浮”到数组的末尾** ！

----

## 冒泡排序：一轮扫描

从下往上，比较每对相邻的数 ── 如果下面的更大就交换：

```text
┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐
│  2  │ │  2  │ │  2  │ │  2  │ │  8  │ ← 8
│  1  │ │  1  │ │  1  │ │  8  │ │  2  │
│  8  │ │  8  │ │  8  │ │  1  │ │  1  │
│  3  │ │  5  │ │  5  │ │  5  │ │  5  │
│  5  │ │  3  │ │  3  │ │  3  │ │  3  │
└─────┘ └─────┘ └─────┘ └─────┘ └─────┘
 5 & 3   3 & 5   5 & 8   8 & 1   8 & 2
 swap!    OK      OK     swap!   swap!
```

> 一轮扫描之后，**最大的** 数就浮到了顶部 ── 它的位置已经确定了！

----

## 冒泡排序：逐轮推进

重复这个过程，直到每个数都"浮"到正确的位置：

```text
 Start   Pass 1   Pass 2   Pass 3   Done!
┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐
│  2  │ │  8  │ │  8  │ │  8  │ │  8  │
│  1  │ │  2  │ │  5  │ │  5  │ │  5  │
│  8  │ │  1  │ │  2  │ │  3  │ │  3  │
│  3  │ │  5  │ │  1  │ │  2  │ │  2  │
│  5  │ │  3  │ │  3  │ │  1  │ │  1  │
└─────┘ └─────┘ └─────┘ └─────┘ └─────┘
           ↑ 8     ↑ 5     ↑ 3
```

> 每完成一轮，顶部就多一个排好的数 ── 下一轮不用再比它了！

----

## 每轮少比一次

每完成一轮，顶部多一个已排好的数，下一轮可以跳过：

| 轮次 | 顶部已排好 | 需要比较 |
|-----:|:----------:|:--------:|
| 第 1 轮 | 0 个 | 4 次 |
| 第 2 轮 | 1 个 | 3 次 |
| 第 3 轮 | 2 个 | 2 次 |
| 第 4 轮 | 3 个 | 1 次 |

> 规律：N 个数，第 `i` 轮比较 `N - 1 - i` 次。

----

## 冒泡排序的 Java 代码

```java
public class BubbleSort {
    public static void main(String[] args) {
        int[] numbers = {5, 3, 8, 1, 2};

        for (int i = 0; i < numbers.length - 1; i++) {
            for (int j = 0; j < numbers.length - 1 - i; j++) {
                if (numbers[j] > numbers[j + 1]) {
                    int temp = numbers[j];
                    numbers[j] = numbers[j + 1];
                    numbers[j + 1] = temp;
                }
            }
        }
        for (int k = 0; k < numbers.length; k++) {
            System.out.println(numbers[k]);
        }
    }
}
```

输出：`1  2  3  5  8`

----

## 代码解析

* **外层循环** （`i`）：记录已经完成了几轮 <!-- .element: class="fragment" -->
* **内层循环** （`j`）：只遍历还没排好的数 ── `- i` 就是跳过顶部已排好的！ <!-- .element: class="fragment" -->
* **交换** ：用一个临时变量 `temp` 来交换两个值 <!-- .element: class="fragment" -->

```java
int temp = numbers[j];          // 先保存左边的值
numbers[j] = numbers[j + 1];   // 把右边的值移到左边
numbers[j + 1] = temp;         // 把保存的值放到右边
```
<!-- .element: class="fragment" -->

> 没有 `temp` ，交换时就会丢失其中一个值！

----

## 需要多少次比较？

| 数据量 | 比较次数（约） |
|-------:|:--------------:|
| 5 | 10 |
| 10 | 45 |
| 100 | ~5,000 |
| 1,000 | ~500,000 |

数据翻倍 ── 工作量变成 **四倍** ！

> 数据量大的时候，冒泡排序太慢了。有更好的办法吗？ <!-- .element: class="fragment" -->

----

## 归并排序：拆开再合并

排 1 个数不用排 ── 那就一直拆，拆到最小再合并！

![归并排序](src/zh/images/merge-sort.svg) <!-- .element: style="width: 55%" -->

> 先 **拆分** ，再 **合并** ── 这就是 **归并排序** ！

----

## 快速排序：选基准分两边

选一个数当 **基准** ，小的放左边，大的放右边：

![快速排序](src/zh/images/quick-sort.svg) <!-- .element: style="width: 55%" -->

> 对 1,000 个数排序：冒泡约 500,000 次比较，快速排序只需约 10,000 次！

----

## 最关键的一课

选择 **正确的算法** 差别巨大：

* 二分搜索 vs 线性搜索 ── 快了百万倍 <!-- .element: class="fragment" -->
* 快速排序 vs 冒泡排序 ── 快了几千倍 <!-- .element: class="fragment" -->

> 数据量越大，选择正确的算法就越重要。

----

## 第 3 章总结

让我们回顾一下走过的路：

* **第 1 章** ── 计算机能理解什么：比特、数字、文字 <!-- .element: class="fragment" -->
* **第 2 章** ── 我们怎么和计算机交流：变量、循环、方法、数组 <!-- .element: class="fragment" -->
* **第 3 章** ── 如何组织数据、聪明地解决问题 <!-- .element: class="fragment" -->

> 你现在不仅会写程序，还知道怎么让程序 **高效运行** 。

----

<!-- .slide: class="center" -->

> 接下来，我们将学习如何 **团队协作** 构建真正的软件 ── 这就是软件工程的意义所在！
