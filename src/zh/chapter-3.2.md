<!-- .slide: class="center" -->

## 3.2. 树

*会分叉的数据*

----

## 所有数据都是一条线吗？

数组、栈和队列都把数据排成一 **条线** ── 一个接一个。

但试着把你的家谱排成一条线 ── 行得通吗？

* 你爸爸和你叔叔是 **并排** 的，不是前后排列 <!-- .element: class="fragment" -->
* 爷爷下面有 **两个** 分支，不是一个 <!-- .element: class="fragment" -->

> 有些数据天生就会 **分叉** ── 一条线装不下。怎么办？

----

## 想想家谱

你一定见过家谱：

```text
        爷爷 & 奶奶
         /        \
       爸爸       叔叔
      /    \        \
    你     妹妹     表弟
```

* **爷爷奶奶** 在最上面 <!-- .element: class="fragment" -->
* 下面是他们的 **孩子** <!-- .element: class="fragment" -->
* 再下面是 **孙辈** <!-- .element: class="fragment" -->

> 数据也可以是这种形状 ── 一个东西连接到下面的好几个东西。

----

## 树的术语

```text
        A         ← 根节点
       / \
      B   C       ← 分支
     / \   \
    D   E   F     ← 叶子节点
```

* **根节点** ── 最顶部的节点（A）。每棵树只有一个。 <!-- .element: class="fragment" -->
* **边** ── 两个节点之间的连线（`/` 和 `\`）。 <!-- .element: class="fragment" -->
* **叶子节点** ── 没有子节点的节点（D、E、F）。 <!-- .element: class="fragment" -->
* **节点** ── 树中的每一项（A、B、C、D、E、F 都是节点）。 <!-- .element: class="fragment" -->

> 在计算机科学里，树是 **倒着长的** ── 根在 **最上面** ！

----

## 你能找到"树"吗？

想一想 ── 下面哪些东西的结构像一棵树？

* 电脑里的文件夹 ── 文件夹套文件夹，最后是文件 <!-- .element: class="fragment" -->
* 学校的组织 ── 校长、年级主任、班主任、学生 <!-- .element: class="fragment" -->
* 淘汰赛 ── 每一轮的胜者进入下一轮 <!-- .element: class="fragment" -->

> 只要数据有 **分叉** ，就能用树来表示。你还能想到别的例子吗？

----

## 二叉树

**二叉树** 是一种特殊的树 ── 每个节点 **最多有 2 个子节点** ，分别叫左孩子和右孩子。

```text
        10
       /  \
      6    15
     / \     \
    3   8    20
```

* 节点 10 有两个子节点：6 和 15 <!-- .element: class="fragment" -->
* 节点 15 只有右孩子：20 <!-- .element: class="fragment" -->
* 节点 3、8 和 20 是叶子节点 ── 它们没有子节点 <!-- .element: class="fragment" -->

> "二叉"就是 **两个分叉** ── 所以每个节点最多分成两条路。

----

## 这棵树有什么规律？

仔细看看这棵二叉树里的数字：

```text
        10
       /  \
      6    15
     / \     \
    3   8    20
```

* 6 比 10 小 ── 放在 **左边** <!-- .element: class="fragment" -->
* 15 比 10 大 ── 放在 **右边** <!-- .element: class="fragment" -->
* 每个节点都是这样：左边小，右边大！ <!-- .element: class="fragment" -->

> 这种"左小右大"的树非常有用 ── 它能帮我们快速找到任何一个数字。

----

## 在树里找数字

想找数字 **8** ，从最上面开始：

```text
        10         8 < 10 → 往左走
       /
      6            8 > 6  → 往右走
       \
        8          找到了！
```

只走了 **3 步** ── 不用像数组一样从头到尾一个一个看！ <!-- .element: class="fragment" -->

> 每走一步，就能排除掉 **一半** 的数字。是不是很像猜数字游戏？

----

## 按顺序读出所有数字

如果我们按"先左、再自己、后右"的规则读这棵树：

```text
        10
       /  \
      6    15
     / \     \
    3   8    20

读出来: 3 → 6 → 8 → 10 → 15 → 20
```

> 发现了吗？数字刚好是 **从小到大** 排列的！"左小右大"的规则让排序变得自然。

----

## 想一想

* 一棵二叉树有 2 层（根 + 一层子节点），能放 3 个节点。3 层呢？ <!-- .element: class="fragment" -->
* 在"左小右大"的树里找数字 20，你会怎么走？ <!-- .element: class="fragment" -->
* 如果树里有 1000 个数字，最多要走几步？ <!-- .element: class="fragment" -->

> 树让数据可以 **分叉** ── 这是一条线做不到的事。

----

<!-- .slide: class="center" -->

> 现在我们学了好几种组织数据的方式 ── 数组、栈、队列和树。接下来，让我们学习 **聪明地** 解决问题 ── 这就是 **算法** 的魅力！
