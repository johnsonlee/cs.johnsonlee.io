<!DOCTYPE html>
<html>
  <head>
    <title>Programming for Kids and Beginners</title>
    <meta charset="utf-8">
    <meta name="author" content="Johnson Lee">
    <meta name="description" content="Programming for Kids and Beginners">
    <meta name="keyword" content="Programming,Kids,Beginners,C,C++,Objective-C,Rust,Java,JavaScript,TypeScript,Python,Kotlin,Swift,Golang,AI,OpenAI,ChatGPT,Gemini,Grok,Claude,LLM,Johnson,johnsonlee">
    <meta name="subject" content="Programming">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      @page { size: 1210px 681px; margin: 0; }

      @media print {
        .remark-slide-scaler { width: 100% !important; height: 100% !important; transform: scale(1) !important; top: 0 !important; left: 0 !important; }
      }

      body { font-family: Graphik, 'Droid Serif'; }
      h1, h2, h3 { font-family: 'Yanone Kaffeesatz'; font-weight: normal; }
      table { border-collapse: collapse; }
      table th, table td { border: 1px solid #ccc; padding: 0.8em; }
      .notation { margin: 0.8em; }
      .toc > ul { columns: 2; column-gap: 2em; }
      .toc > ul > li { break-inside: avoid; margin-bottom: 0.4em; }
      .toc > ul > li > :first-child { margin: 0 auto 0.4em auto; }
      .remark-code, .remark-inline-code { font-family: 'Source Code Pro'; }
      .remark-slide-content img { display: block; margin: 0 auto; max-width: 90%; max-height: 90%; object-fit: cover; }
      .remark-slide-content blockquote { margin: 0.8em 0em; padding: 0.4em 0.8em; border-left: 6px solid #4a90e2; font-style: italic; font-size: 1.2em; color: #333; background: #f7f9fc; }
      .remark-slide-content.inverse { background: #000; color: #a3a3a3; }
      .remark-slide:has(> .remark-slide-content.flex) { display: flex !important;}
      .remark-slide-content.flex, .remark-slide-content.flex .flex { flex: 1; align-self: stretch; display: flex; flex-direction: column; }
      .remark-slide-content.flex > h1, .remark-slide-content.flex > .footnote, .remark-slide-content.flex > .remark-slide-number { flex: 0!important; }
      .remark-slide-content.flex > h1 + :not(.footnote):has(+ .footnote),
      .remark-slide-content.flex > h1 + :not(.footnote):has(+ .remark-slide-number) { flex: 1; min-height: 0; margin-top: 0!important; margin-bottom: 0!important; display: flex; flex-direction: column; justify-content: space-evenly; }
      .remark-slide-content.flex > h1 + :not(.footnote):has(+ .footnote).p,
      .remark-slide-content.flex > h1 + :not(.footnote):has(+ .remark-slide-number).p { justify-content: start!important; }
      .remark-slide-content.flex > h1 + :not(.footnote):has(+ .footnote).middle,
      .remark-slide-content.flex > h1 + :not(.footnote):has(+ .remark-slide-number).middle { justify-content: center!important; }
    </style>
  </head>
  <body>
    <textarea id="source">
class: center, middle

# Programming for Kids and Beginners

.footnote[
Johnson Li, 2026
]
---
class: flex

# Outline

- Chapter 1: Information Representation
- Chapter 2: Programming Language
- Chapter 3: Data Structure & Algorithms
- Chapter 4: Software Engineering

.footnote[
&nbsp;
]

---
# Chapter 1: Information Representation

.toc[
- Number Representation

  - Decimal
  - Binary
  - Hexadecimal
  - Positional Numeral System
  - Base Notation
  - Scientific Notation
  - Engineering Notation
  - BCD Code
  - Number Base Conversion
  - Numbers in Memory

- Text Representation

  - ASCII
  - Unicode

- Color Representation

  - RGB Color Model
  - CMYK Color Model

- Image Representation

  - Raster vs Vector
  - PGM
  - SVG

- Program Representation

  - Programs as Text
  - Program vs Data
]

.footnote[
&nbsp;
]

---
class: center, middle, inverse

# How Computer Represents Information?

---
class: flex

# Information Representation

- Number
- Text
- Color
- Image / Video
- Audio
- Program Instructions / Binary Data / etc.
- ...

.footnote[
&nbsp;
]

---

class: center, middle, inverse

# How Computer Represents Numbers?

---
class: flex

# How do Human Count?

.p[
Before computers,

Humans were already counting.

> How did we start counting in the first place?
]

---
class: flex

# Counting with Fingers!

.p[
Humans have 10 fingers:

![10 fingers](https://www.emoji.family/api/emojis/1f450/noto/png/256)

> So, counting in gorup of 10 feels natural to us.
]

---
# Decimal

We use **decimal** symbols (digits):
.center[
> 0 1 2 3 4 5 6 7 8 9
]

After 9, we run out of symbols, then:

- Go back to 0
- Carry 1 to the next position

.p[
&nbsp;
]
**This rule is not about math, it's about representation.**

---
class: flex

# What does "Decimal" Mean?

.p[
Decimal means:
- **10** symbols
- Each position is worth a power of **10**

The values comes from the **position**.

> ```
> 345 = 300 + 40 + 5
>     = 3 √ó 10¬≤ + 4 √ó 10¬π + 5 √ó 10‚Å∞
> ```
]
---
class: flex

# Is Decimal the Only Way to Count?

.middle[
> Decimal is a human choice.
]
.footnote[
&nbsp;
]

---
class: flex

# Computer's Choice

If **decimal** comes from human hands,

What kind of "hands" do computers have?

> Computers also have a choice.
>  
> But their choice is limited by ‚Äî‚Äî **hardware**.

.footnote[
&nbsp;
]

---
class: flex

# Hardware Limits the Choice

.p[
At the lowest level, a computer can only reliably tell:

- `ON / OFF`
- `High / Low`
- `1 / 0`

> This makes **binary** a natural choice.
]

---
class: flex

# Binary

Computers use binary digits:

.center[
> 0 1
]

.p[
Just like **decimal**:
- There are only 2 symbols
- Each position has a weight (a power of 2)

The values also comes from the **position**:

  ```
  1010 = 1 √ó 2¬≥ + 0 √ó 2¬≤ + 1 √ó 2¬π + 0 √ó 2‚Å∞
  ```
]

---
class: flex

# Hexadecimal

Just like **decimal** and **binary**:
- Hexadecimal has 16 symbols: `0 1 2 3 4 5 6 7 8 9 A B C D E F`
- Each position has a weight (a power of 16)

The value also comes from the **position**:

  ```
  12A = 1 √ó 16¬≤ + 2 √ó 16¬π + 10 √ó 16‚Å∞
  ```

So, binary and hexadecimal follow the same idea as decimal.

---
class: middle

# This shared idea has a name -- Positional Numeral System

---
class: flex

# Different Representations

We write numbers using symbols:
- 42
- 101010
- 2A

The look different, but can represent the same value.

> What makes them different?

---
class: flex

# What's NOT the Difference?

The difference is NOT:
- The value
- The idea of counting

---
class: flex

# Number of Symbols Matters

Each representation uses a different set of symbols:

- Decimal uses 10 symbols ‚Üí `0-9`
- Binary uses 2 symbols ‚Üí `0, 1`
- Hexadecimal uses 16 symbols ‚Üí `0-9, A-Z`

This is called:
> The **Base (Radix)** of a Number System

---
class: flex

# Base Notation

Any number expressed in base ùëè can be represented as follows:

<div class="notation">
$$
(d_n d_{n-1} \dots d_1 d_0)_b
$$
</div>

| Base | Digits                          | Notation   |
|:----:|:-------------------------------:|:----------:|
| 2    | 0 1                             | (1010)‚ÇÇ    |
| 10   | 0 1 2 3 4 5 6 7 8 9             | (42)‚ÇÅ‚ÇÄ     |
| 16   | 0 1 2 3 4 5 6 7 8 9 A B C D E F | (2A)‚ÇÅ‚ÇÜ     |

.footnote[
&nbsp;
]

---
class: center, middle, inverse

# How Computer Stores Numbers?

---
class: flex

# Numbers in Binary

We know that numbers are represented in binary digits.

Inside a computer, binary digits are represented as **bits**.

```
Digits :   1    0    1    0

           ‚Üì    ‚Üì    ‚Üì    ‚Üì

Bits   :   1    0    1    0
```

> Where do these bits live?

.footnote[
&nbsp;
]
---
class: flex

# Bits Live in Memory

Bits are stored in **memory** in groups. A group of 8 bits is called a **byte**.

Memory is a long sequence of bytes:

.center[
```
+--------+--------+--------+--------+--------+--------+--------+
| byte 0 | byte 1 | byte 2 | byte 3 | byte 4 |  ....  | byte N |
+--------+--------+--------+--------+--------+--------+--------+
‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì
10100101
```
]

Memory has order, bits are stored next to each other.

In real program, we store many numbers in memory.

So, we need a way to know **where one number ends and the next one begins**.
---
class: flex

# A Natural Idea

.p[
Numbers can be:
- small: `123`
- large: `23456789`

Why no use:
- fewer bits for small numbers
- more bits for large numbers?

> This sounds efficient, right?
]
---
class: flex

# A Problem with Variable Length

If numbers use different numbers of bits,

How do we find the next numbers?

> To find the 10th number, do we have to count from the beginning?
---
class: center, middle

# What if each number uses the same number of bits?
---
class: flex

# Fixed-size Numbers

With fixed-size numbers, the position of each number is predictable.

Fixed size solves:
> Where is the next number?

But we still need to choose:
> How many bits per number?

.footnote[
&nbsp;
]
---
class: flex

# Bit-width

The number of bits used for one number is called its **bit-width**.

Common choices:

```
  bit-width | bits
------------+--------------------------------------------------------------
    8-bit   | ‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢
   16-bit   | ‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢
   32-bit   | ‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢
   64-bit   | ‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢
```

> Why not always use 64-bits?
---
class: flex

# Bit-width is a Trade-off

More bits means:
- larger range
- more memory

Fewer bits means:
- smaller range
- less memory
---
class: flex

# A Quick Thought

If we store 1,000,000 numbers:

- 8-bit ‚Üí 1MB
- 32-bit ‚Üí 4MB
- 64-bit ‚Üí 8MB

> Same count of numbers, different memory cost.  
>  
> This matters in real programs.
---
class: flex

# Negative Numbers

So far, we can store numbers in bits.

But what about negative numbers?

How do we store:
- -1
- -10
- -100?
- ...
---
class: flex

# Back to Number System

In a **Positional Numeral System**, digits represent **Place Values**, they tell us:

> How big a number is.

But digits have no idea about **direction** (positive or negative).

They only represent magnitude, no sign.

---
class: flex

# Where does the Sign Come From?

If digits only represent magnitude...

Then we must use some bits to represent **sign**.

> A natural choice is -- using 1 bit to represent the **sign**

---
class: flex

# Signed Numbers Representation

.center[
```
 bit-width | bits                                                             
-----------+------------------------------------------------------------------
    8-bit  | ‚óå‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢                                                         
   16-bit  | ‚óå‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢                                                
   32-bit  | ‚óå‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢                                
   64-bit  | ‚óå‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢‚ñ¢


  ‚óå ‚Üí sign     
  ‚ñ¢ ‚Üí magnitude
```
]
.footnote[
&nbsp;
]
---
class: flex

# Cost of Sign

Using a sign means:
- fewer bits for magnitude
- smaller range of values

What about ...
- age
- number of students
- ...

> Do we always need the **sign**?

---
class: flex

# Unsigned Numbers

If we don't need negative numbers,

We can use all bits for magnitude.

> This interpretation is called -- **Unsigned**

---
class: flex

# Integer Range : Signed vs Unsigned

.center[
```
+-----------+----------------------+----------------------+
| bit-width |    Unsigned Range    |     Signed Range     |
+-----------+----------------------+----------------------+
|    8-bit  |     0 ~ 2^8 ‚àí 1      |   ‚àí2^7  ~ 2^7 ‚àí 1    |
|   16-bit  |     0 ~ 2^16 ‚àí 1     |   ‚àí2^15 ~ 2^15 ‚àí 1   |
|   32-bit  |     0 ~ 2^32 ‚àí 1     |   ‚àí2^31 ~ 2^31 ‚àí 1   |
|   64-bit  |     0 ~ 2^64 ‚àí 1     |   ‚àí2^63 ~ 2^63 ‚àí 1   |
+-----------+----------------------+----------------------+
```
]
.footnote[
> Signed numbers give up **half the range** to get **sign**:

&nbsp;
]

---
class: flex

# Non-integers

What about numbers like:

- 3.1415926
- 0.1
- -2.5

Can we just store:

<div class="notation">
$$
3.1415926 \times 10000000 = 31415926
$$
</div>

> What about `1/3`?
---
class: flex

# A New Difficulty

If we scale numbers:

- How many decimal places do we keep?

- What if the number is very large?

- What if it is very small?

> We need to represent both **size** and **precision**

---
class: flex

# What We Want?

We want a way to represent:

- very large numbers

- very small numbers

- with limited bits

---
class: flex

# Scientific Notation

In math, we can write:

- 3.1415926 √ó 10^2

- 1.2 √ó 10^‚àí5

This is **Scientific Notation**.

---
class: flex

# Floating Point Representation

Computers do something similar:

<div class="notation">
$$
Number = Mantissa \times Base^{exponent}
$$
</div>

---
class: flex

# Representation: Integer vs Floating

.middle[
- Integers ‚Üí exact

- Floating Point ‚Üí approximate

> Floating point numbers trade exactness for range
]

---
class: center, middle, inverse

# How Computer Represents Text?

---
class: flex

# From Characters to Bits

.center[
```
Text / Characters

‚Üì

Code Points

‚Üì

Encoded Bytes

‚Üì

Binary Bits
```
]

.footnote[
&nbsp;
]

---
class: flex

# ASCII : <u>A</u>merican <u>S</u>tandard <u>C</u>ode for <u>I</u>nformation <u>I</u>nterchange

![ASCII](https://upload.wikimedia.org/wikipedia/commons/4/4c/USASCII_code_chart.svg)

.footnote[
* https://en.wikipedia.org/wiki/ASCII
]

---

class: flex

# English Characters as Numbers

.center[
```
'A'

‚Üì

0x41 (65)

‚Üì

0100 0001
```
]

.footnote[
* https://en.wikipedia.org/wiki/ASCII
]
---
class: center, middle, inverse

# How Computer Represents Chinese Characters?

---
class: flex

# Unicode Character Set

.center[
```
Character ('‰∏≠')

‚Üì

Unicode Code Point (U+4E2D)

‚Üì

Unicode Encoded Bytes (E4 B8 AD)

‚Üì

Bits (11100100 10111000 10101101)
```
]

.footnote[
* https://en.wikipedia.org/wiki/Unicode
]

---
# Why ASCII is Not Enough?

ASCII can represent:
- English Letters
- Numbers

But not:
- Chinese
- Japanese
- Korean
- Emoji

---
class: flex

# Other Character Sets

- ISO 8859-1
- GBK
- GB2312
- GB18030
- ...

.footnote[
* https://en.wikipedia.org/wiki/Character_encoding
]
    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        options: {
          skipHtmlTags: ['script','noscript','style','textarea','pre','code']
        }
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
      let slideshow = remark.create({
        ratio: '16:9'
      });
      slideshow.on('afterShowSlide', function (e) {
        MathJax.typesetPromise();
      });
    </script>
  </body>
</html>
